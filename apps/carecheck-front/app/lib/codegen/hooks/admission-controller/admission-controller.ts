/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * carecheck
 * api Î¨∏ÏÑú
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetAdmissionListBySearchValue200,
  GetAdmissionListBySearchValueParams,
  GetAllPatientsByName200,
  GetAllPatientsByNameParams,
  GetAllWaitingList200,
  GetAllWaitingListParams,
  InsertAdm200,
  InsertDiagnosisInAdm200,
  InsertOrderInAdm200,
  InsertVitalInfoByAdmId200,
  ReqAddAdmissionDto,
  ReqAddDiagnosisInAdmDto,
  ReqAddOrderInAdmDto,
  ReqAddVitalInAdmDto,
  SearchPatientInfoByAdmId200,
  SelectDetailBill200,
  SelectTotalPayInAdm200,
  SelectVitalInfo200,
  SelectWaitingList200,
  UpdateAdmissionComplete200,
  UpdateAdmissionStart200
} from '../../dtos';

import { customInstance } from '../../../axios-client/customClient';
import type { ErrorType , BodyType } from '../../../axios-client/customClient';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * ÏÑ†ÌÉùÌïú Ï†ëÏàòÎ≤àÌò∏Ïùò ÏßÑÎ£åÏãúÏûë
 * @summary ÏßÑÎ£åÏãúÏûë
 */
export const updateAdmissionStart = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAdmissionStart200>(
      {url: `/api/admission/${admissionId}/start`, method: 'PUT'
    },
      options);
    }
  


export const getUpdateAdmissionStartMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionStart>>, TError,{admissionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionStart>>, TError,{admissionId: number}, TContext> => {
    
const mutationKey = ['updateAdmissionStart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdmissionStart>>, {admissionId: number}> = (props) => {
          const {admissionId} = props ?? {};

          return  updateAdmissionStart(admissionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdmissionStartMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdmissionStart>>>
    
    export type UpdateAdmissionStartMutationError = ErrorType<unknown>

    /**
 * @summary ÏßÑÎ£åÏãúÏûë
 */
export const useUpdateAdmissionStart = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionStart>>, TError,{admissionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdmissionStart>>,
        TError,
        {admissionId: number},
        TContext
      > => {

      const mutationOptions = getUpdateAdmissionStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ÏÑ†ÌÉùÌïú Ï†ëÏàòÎ≤àÌò∏Ïùò ÏßÑÎ£åÏôÑÎ£å
 * @summary ÏßÑÎ£åÏôÑÎ£å
 */
export const updateAdmissionComplete = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAdmissionComplete200>(
      {url: `/api/admission/${admissionId}/complete`, method: 'PUT'
    },
      options);
    }
  


export const getUpdateAdmissionCompleteMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionComplete>>, TError,{admissionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionComplete>>, TError,{admissionId: number}, TContext> => {
    
const mutationKey = ['updateAdmissionComplete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdmissionComplete>>, {admissionId: number}> = (props) => {
          const {admissionId} = props ?? {};

          return  updateAdmissionComplete(admissionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdmissionCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdmissionComplete>>>
    
    export type UpdateAdmissionCompleteMutationError = ErrorType<unknown>

    /**
 * @summary ÏßÑÎ£åÏôÑÎ£å
 */
export const useUpdateAdmissionComplete = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionComplete>>, TError,{admissionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdmissionComplete>>,
        TError,
        {admissionId: number},
        TContext
      > => {

      const mutationOptions = getUpdateAdmissionCompleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Ï†ëÏàòÎì±Î°ù
 * @summary ÏßÑÎ£åÏ†ëÏàò
 */
export const insertAdm = (
    reqAddAdmissionDto: BodyType<ReqAddAdmissionDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<InsertAdm200>(
      {url: `/api/admission`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reqAddAdmissionDto, signal
    },
      options);
    }
  


export const getInsertAdmMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertAdm>>, TError,{data: BodyType<ReqAddAdmissionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof insertAdm>>, TError,{data: BodyType<ReqAddAdmissionDto>}, TContext> => {
    
const mutationKey = ['insertAdm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertAdm>>, {data: BodyType<ReqAddAdmissionDto>}> = (props) => {
          const {data} = props ?? {};

          return  insertAdm(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InsertAdmMutationResult = NonNullable<Awaited<ReturnType<typeof insertAdm>>>
    export type InsertAdmMutationBody = BodyType<ReqAddAdmissionDto>
    export type InsertAdmMutationError = ErrorType<unknown>

    /**
 * @summary ÏßÑÎ£åÏ†ëÏàò
 */
export const useInsertAdm = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertAdm>>, TError,{data: BodyType<ReqAddAdmissionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof insertAdm>>,
        TError,
        {data: BodyType<ReqAddAdmissionDto>},
        TContext
      > => {

      const mutationOptions = getInsertAdmMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ÏÑ†ÌÉùÌôòÏûêÏùò Î∞îÏù¥ÌÉà Ï†ïÎ≥¥
 * @summary ÌôòÏûêÎ∞îÏù¥ÌÉàÏ†ïÎ≥¥
 */
export const selectVitalInfo = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SelectVitalInfo200>(
      {url: `/api/admission/${admissionId}/vitals`, method: 'GET', signal
    },
      options);
    }
  

export const getSelectVitalInfoQueryKey = (admissionId: number,) => {
    return [`/api/admission/${admissionId}/vitals`] as const;
    }

    
export const getSelectVitalInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof selectVitalInfo>>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectVitalInfoQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectVitalInfo>>> = ({ signal }) => selectVitalInfo(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectVitalInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof selectVitalInfo>>>
export type SelectVitalInfoInfiniteQueryError = ErrorType<unknown>


export function useSelectVitalInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectVitalInfo>>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectVitalInfo>>,
          TError,
          Awaited<ReturnType<typeof selectVitalInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectVitalInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectVitalInfo>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectVitalInfo>>,
          TError,
          Awaited<ReturnType<typeof selectVitalInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectVitalInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectVitalInfo>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌôòÏûêÎ∞îÏù¥ÌÉàÏ†ïÎ≥¥
 */

export function useSelectVitalInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectVitalInfo>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectVitalInfoInfiniteQueryOptions(admissionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSelectVitalInfoQueryOptions = <TData = Awaited<ReturnType<typeof selectVitalInfo>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectVitalInfoQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectVitalInfo>>> = ({ signal }) => selectVitalInfo(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectVitalInfoQueryResult = NonNullable<Awaited<ReturnType<typeof selectVitalInfo>>>
export type SelectVitalInfoQueryError = ErrorType<unknown>


export function useSelectVitalInfo<TData = Awaited<ReturnType<typeof selectVitalInfo>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectVitalInfo>>,
          TError,
          Awaited<ReturnType<typeof selectVitalInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectVitalInfo<TData = Awaited<ReturnType<typeof selectVitalInfo>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectVitalInfo>>,
          TError,
          Awaited<ReturnType<typeof selectVitalInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectVitalInfo<TData = Awaited<ReturnType<typeof selectVitalInfo>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌôòÏûêÎ∞îÏù¥ÌÉàÏ†ïÎ≥¥
 */

export function useSelectVitalInfo<TData = Awaited<ReturnType<typeof selectVitalInfo>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectVitalInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectVitalInfoQueryOptions(admissionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ìï¥ÎãπÏ†ëÏàòÎ≤àÌò∏Ïóê Îì±Î°ùÎêú Î∞îÏù¥ÌÉà Ï†ïÎ≥¥
 * @summary ÌôòÏûêÎ∞îÏù¥ÌÉàÏûÖÎ†•
 */
export const insertVitalInfoByAdmId = (
    admissionId: number,
    reqAddVitalInAdmDto: BodyType<ReqAddVitalInAdmDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<InsertVitalInfoByAdmId200>(
      {url: `/api/admission/${admissionId}/vitals`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reqAddVitalInAdmDto, signal
    },
      options);
    }
  


export const getInsertVitalInfoByAdmIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertVitalInfoByAdmId>>, TError,{admissionId: number;data: BodyType<ReqAddVitalInAdmDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof insertVitalInfoByAdmId>>, TError,{admissionId: number;data: BodyType<ReqAddVitalInAdmDto>}, TContext> => {
    
const mutationKey = ['insertVitalInfoByAdmId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertVitalInfoByAdmId>>, {admissionId: number;data: BodyType<ReqAddVitalInAdmDto>}> = (props) => {
          const {admissionId,data} = props ?? {};

          return  insertVitalInfoByAdmId(admissionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InsertVitalInfoByAdmIdMutationResult = NonNullable<Awaited<ReturnType<typeof insertVitalInfoByAdmId>>>
    export type InsertVitalInfoByAdmIdMutationBody = BodyType<ReqAddVitalInAdmDto>
    export type InsertVitalInfoByAdmIdMutationError = ErrorType<unknown>

    /**
 * @summary ÌôòÏûêÎ∞îÏù¥ÌÉàÏûÖÎ†•
 */
export const useInsertVitalInfoByAdmId = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertVitalInfoByAdmId>>, TError,{admissionId: number;data: BodyType<ReqAddVitalInAdmDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof insertVitalInfoByAdmId>>,
        TError,
        {admissionId: number;data: BodyType<ReqAddVitalInAdmDto>},
        TContext
      > => {

      const mutationOptions = getInsertVitalInfoByAdmIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ÏÑ†ÌÉùÌïú Ï†ëÏàòÎ≤àÌò∏Ïóê Ï≤òÎ∞©ÏûÖÎ†•
 * @summary Ïò§ÎçîÏûÖÎ†•
 */
export const insertOrderInAdm = (
    admissionId: number,
    reqAddOrderInAdmDto: BodyType<ReqAddOrderInAdmDto[]>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<InsertOrderInAdm200>(
      {url: `/api/admission/${admissionId}/orders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reqAddOrderInAdmDto, signal
    },
      options);
    }
  


export const getInsertOrderInAdmMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertOrderInAdm>>, TError,{admissionId: number;data: BodyType<ReqAddOrderInAdmDto[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof insertOrderInAdm>>, TError,{admissionId: number;data: BodyType<ReqAddOrderInAdmDto[]>}, TContext> => {
    
const mutationKey = ['insertOrderInAdm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertOrderInAdm>>, {admissionId: number;data: BodyType<ReqAddOrderInAdmDto[]>}> = (props) => {
          const {admissionId,data} = props ?? {};

          return  insertOrderInAdm(admissionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InsertOrderInAdmMutationResult = NonNullable<Awaited<ReturnType<typeof insertOrderInAdm>>>
    export type InsertOrderInAdmMutationBody = BodyType<ReqAddOrderInAdmDto[]>
    export type InsertOrderInAdmMutationError = ErrorType<unknown>

    /**
 * @summary Ïò§ÎçîÏûÖÎ†•
 */
export const useInsertOrderInAdm = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertOrderInAdm>>, TError,{admissionId: number;data: BodyType<ReqAddOrderInAdmDto[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof insertOrderInAdm>>,
        TError,
        {admissionId: number;data: BodyType<ReqAddOrderInAdmDto[]>},
        TContext
      > => {

      const mutationOptions = getInsertOrderInAdmMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ÏÑ†ÌÉùÌïú Ï†ëÏàòÎ≤àÌò∏Ïóê Ï£ºÏßÑÎã®ÏûÖÎ†•
 * @summary ÏßÑÎã®ÏûÖÎ†•
 */
export const insertDiagnosisInAdm = (
    admissionId: number,
    reqAddDiagnosisInAdmDto: BodyType<ReqAddDiagnosisInAdmDto[]>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<InsertDiagnosisInAdm200>(
      {url: `/api/admission/${admissionId}/diagnosis`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reqAddDiagnosisInAdmDto, signal
    },
      options);
    }
  


export const getInsertDiagnosisInAdmMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertDiagnosisInAdm>>, TError,{admissionId: number;data: BodyType<ReqAddDiagnosisInAdmDto[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof insertDiagnosisInAdm>>, TError,{admissionId: number;data: BodyType<ReqAddDiagnosisInAdmDto[]>}, TContext> => {
    
const mutationKey = ['insertDiagnosisInAdm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertDiagnosisInAdm>>, {admissionId: number;data: BodyType<ReqAddDiagnosisInAdmDto[]>}> = (props) => {
          const {admissionId,data} = props ?? {};

          return  insertDiagnosisInAdm(admissionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InsertDiagnosisInAdmMutationResult = NonNullable<Awaited<ReturnType<typeof insertDiagnosisInAdm>>>
    export type InsertDiagnosisInAdmMutationBody = BodyType<ReqAddDiagnosisInAdmDto[]>
    export type InsertDiagnosisInAdmMutationError = ErrorType<unknown>

    /**
 * @summary ÏßÑÎã®ÏûÖÎ†•
 */
export const useInsertDiagnosisInAdm = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof insertDiagnosisInAdm>>, TError,{admissionId: number;data: BodyType<ReqAddDiagnosisInAdmDto[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof insertDiagnosisInAdm>>,
        TError,
        {admissionId: number;data: BodyType<ReqAddDiagnosisInAdmDto[]>},
        TContext
      > => {

      const mutationOptions = getInsertDiagnosisInAdmMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * admIdÎ•º Ïù¥Ïö©, Ï†ëÏàòÎêú ÌôòÏûêÏ†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
 * @summary Ï†ëÏàòÏÑ∏Î∂ÄÏ†ïÎ≥¥
 */
export const searchPatientInfoByAdmId = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SearchPatientInfoByAdmId200>(
      {url: `/api/admission/${admissionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSearchPatientInfoByAdmIdQueryKey = (admissionId: number,) => {
    return [`/api/admission/${admissionId}`] as const;
    }

    
export const getSearchPatientInfoByAdmIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchPatientInfoByAdmIdQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>> = ({ signal }) => searchPatientInfoByAdmId(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchPatientInfoByAdmIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>
export type SearchPatientInfoByAdmIdInfiniteQueryError = ErrorType<unknown>


export function useSearchPatientInfoByAdmIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>,
          TError,
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchPatientInfoByAdmIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>,
          TError,
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchPatientInfoByAdmIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï†ëÏàòÏÑ∏Î∂ÄÏ†ïÎ≥¥
 */

export function useSearchPatientInfoByAdmIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchPatientInfoByAdmIdInfiniteQueryOptions(admissionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchPatientInfoByAdmIdQueryOptions = <TData = Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchPatientInfoByAdmIdQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>> = ({ signal }) => searchPatientInfoByAdmId(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchPatientInfoByAdmIdQueryResult = NonNullable<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>>
export type SearchPatientInfoByAdmIdQueryError = ErrorType<unknown>


export function useSearchPatientInfoByAdmId<TData = Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>,
          TError,
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchPatientInfoByAdmId<TData = Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>,
          TError,
          Awaited<ReturnType<typeof searchPatientInfoByAdmId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchPatientInfoByAdmId<TData = Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï†ëÏàòÏÑ∏Î∂ÄÏ†ïÎ≥¥
 */

export function useSearchPatientInfoByAdmId<TData = Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPatientInfoByAdmId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchPatientInfoByAdmIdQueryOptions(admissionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ï†ëÏàòÎêú ÎåÄÍ∏∞Ïûê Î™ÖÎã® ÏÇ≠Ï†ú
 * @summary Ï†ëÏàòÎêú Ï†ÑÏ≤¥ ÎåÄÍ∏∞Ïûê Î™ÖÎã®
 */
export const deletePatientByAdmId = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/admission/${admissionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePatientByAdmIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientByAdmId>>, TError,{admissionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientByAdmId>>, TError,{admissionId: number}, TContext> => {
    
const mutationKey = ['deletePatientByAdmId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientByAdmId>>, {admissionId: number}> = (props) => {
          const {admissionId} = props ?? {};

          return  deletePatientByAdmId(admissionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientByAdmIdMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientByAdmId>>>
    
    export type DeletePatientByAdmIdMutationError = ErrorType<unknown>

    /**
 * @summary Ï†ëÏàòÎêú Ï†ÑÏ≤¥ ÎåÄÍ∏∞Ïûê Î™ÖÎã®
 */
export const useDeletePatientByAdmId = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientByAdmId>>, TError,{admissionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientByAdmId>>,
        TError,
        {admissionId: number},
        TContext
      > => {

      const mutationOptions = getDeletePatientByAdmIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ÏÑ†ÌÉùÌïú Ï†ëÏàòÎ≤àÌò∏Ïùò Ï¥ùÍ∏àÏï°
 * @summary Í∏àÏï° Ï°∞Ìöå
 */
export const selectTotalPayInAdm = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SelectTotalPayInAdm200>(
      {url: `/api/admission/${admissionId}/totalpay`, method: 'GET', signal
    },
      options);
    }
  

export const getSelectTotalPayInAdmQueryKey = (admissionId: number,) => {
    return [`/api/admission/${admissionId}/totalpay`] as const;
    }

    
export const getSelectTotalPayInAdmInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof selectTotalPayInAdm>>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectTotalPayInAdmQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectTotalPayInAdm>>> = ({ signal }) => selectTotalPayInAdm(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectTotalPayInAdmInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof selectTotalPayInAdm>>>
export type SelectTotalPayInAdmInfiniteQueryError = ErrorType<unknown>


export function useSelectTotalPayInAdmInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectTotalPayInAdm>>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectTotalPayInAdm>>,
          TError,
          Awaited<ReturnType<typeof selectTotalPayInAdm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectTotalPayInAdmInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectTotalPayInAdm>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectTotalPayInAdm>>,
          TError,
          Awaited<ReturnType<typeof selectTotalPayInAdm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectTotalPayInAdmInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectTotalPayInAdm>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í∏àÏï° Ï°∞Ìöå
 */

export function useSelectTotalPayInAdmInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectTotalPayInAdm>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectTotalPayInAdmInfiniteQueryOptions(admissionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSelectTotalPayInAdmQueryOptions = <TData = Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectTotalPayInAdmQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectTotalPayInAdm>>> = ({ signal }) => selectTotalPayInAdm(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectTotalPayInAdmQueryResult = NonNullable<Awaited<ReturnType<typeof selectTotalPayInAdm>>>
export type SelectTotalPayInAdmQueryError = ErrorType<unknown>


export function useSelectTotalPayInAdm<TData = Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectTotalPayInAdm>>,
          TError,
          Awaited<ReturnType<typeof selectTotalPayInAdm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectTotalPayInAdm<TData = Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectTotalPayInAdm>>,
          TError,
          Awaited<ReturnType<typeof selectTotalPayInAdm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectTotalPayInAdm<TData = Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Í∏àÏï° Ï°∞Ìöå
 */

export function useSelectTotalPayInAdm<TData = Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectTotalPayInAdm>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectTotalPayInAdmQueryOptions(admissionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÏÑ†ÌÉùÌïúÏ†ëÏàòÎ≤àÌò∏Ïùò ÏÑ∏Î∂ÄÎÇ¥Ïó≠
 * @summary ÏßÑÎ£åÏÑ∏Î∂ÄÎÇ¥Ïó≠
 */
export const selectDetailBill = (
    admissionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SelectDetailBill200>(
      {url: `/api/admission/${admissionId}/billings`, method: 'GET', signal
    },
      options);
    }
  

export const getSelectDetailBillQueryKey = (admissionId: number,) => {
    return [`/api/admission/${admissionId}/billings`] as const;
    }

    
export const getSelectDetailBillInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof selectDetailBill>>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectDetailBillQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectDetailBill>>> = ({ signal }) => selectDetailBill(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectDetailBillInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof selectDetailBill>>>
export type SelectDetailBillInfiniteQueryError = ErrorType<unknown>


export function useSelectDetailBillInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectDetailBill>>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectDetailBill>>,
          TError,
          Awaited<ReturnType<typeof selectDetailBill>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectDetailBillInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectDetailBill>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectDetailBill>>,
          TError,
          Awaited<ReturnType<typeof selectDetailBill>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectDetailBillInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectDetailBill>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏßÑÎ£åÏÑ∏Î∂ÄÎÇ¥Ïó≠
 */

export function useSelectDetailBillInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectDetailBill>>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectDetailBillInfiniteQueryOptions(admissionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSelectDetailBillQueryOptions = <TData = Awaited<ReturnType<typeof selectDetailBill>>, TError = ErrorType<unknown>>(admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectDetailBillQueryKey(admissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectDetailBill>>> = ({ signal }) => selectDetailBill(admissionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(admissionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectDetailBillQueryResult = NonNullable<Awaited<ReturnType<typeof selectDetailBill>>>
export type SelectDetailBillQueryError = ErrorType<unknown>


export function useSelectDetailBill<TData = Awaited<ReturnType<typeof selectDetailBill>>, TError = ErrorType<unknown>>(
 admissionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectDetailBill>>,
          TError,
          Awaited<ReturnType<typeof selectDetailBill>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectDetailBill<TData = Awaited<ReturnType<typeof selectDetailBill>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectDetailBill>>,
          TError,
          Awaited<ReturnType<typeof selectDetailBill>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectDetailBill<TData = Awaited<ReturnType<typeof selectDetailBill>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏßÑÎ£åÏÑ∏Î∂ÄÎÇ¥Ïó≠
 */

export function useSelectDetailBill<TData = Awaited<ReturnType<typeof selectDetailBill>>, TError = ErrorType<unknown>>(
 admissionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectDetailBill>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectDetailBillQueryOptions(admissionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÏßÅÏõêÏΩîÎìúÎ°ú Îì±Î°ùÎêú ÎåÄÍ∏∞ÏûêÎ™ÖÎã®
 * @summary ÏßÑÎ£åÎåÄÍ∏∞ÏûêÎ™ÖÎã®
 */
export const selectWaitingList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SelectWaitingList200>(
      {url: `/api/admission/waitings`, method: 'GET', signal
    },
      options);
    }
  

export const getSelectWaitingListQueryKey = () => {
    return [`/api/admission/waitings`] as const;
    }

    
export const getSelectWaitingListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof selectWaitingList>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectWaitingListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectWaitingList>>> = ({ signal }) => selectWaitingList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectWaitingListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof selectWaitingList>>>
export type SelectWaitingListInfiniteQueryError = ErrorType<unknown>


export function useSelectWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectWaitingList>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectWaitingList>>,
          TError,
          Awaited<ReturnType<typeof selectWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectWaitingList>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectWaitingList>>,
          TError,
          Awaited<ReturnType<typeof selectWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectWaitingList>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏßÑÎ£åÎåÄÍ∏∞ÏûêÎ™ÖÎã®
 */

export function useSelectWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof selectWaitingList>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectWaitingListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSelectWaitingListQueryOptions = <TData = Awaited<ReturnType<typeof selectWaitingList>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSelectWaitingListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof selectWaitingList>>> = ({ signal }) => selectWaitingList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SelectWaitingListQueryResult = NonNullable<Awaited<ReturnType<typeof selectWaitingList>>>
export type SelectWaitingListQueryError = ErrorType<unknown>


export function useSelectWaitingList<TData = Awaited<ReturnType<typeof selectWaitingList>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectWaitingList>>,
          TError,
          Awaited<ReturnType<typeof selectWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectWaitingList<TData = Awaited<ReturnType<typeof selectWaitingList>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof selectWaitingList>>,
          TError,
          Awaited<ReturnType<typeof selectWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSelectWaitingList<TData = Awaited<ReturnType<typeof selectWaitingList>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏßÑÎ£åÎåÄÍ∏∞ÏûêÎ™ÖÎã®
 */

export function useSelectWaitingList<TData = Awaited<ReturnType<typeof selectWaitingList>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof selectWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSelectWaitingListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ReceiptPage - Ïò§Îäò Ï†ëÏàòÎêú ÌôòÏûê Î™ÖÎã®
 * @summary Ïò§Îäò ÌôòÏûê Ï†ëÏàò Î™ÖÎã®
 */
export const getAllWaitingList = (
    params: GetAllWaitingListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAllWaitingList200>(
      {url: `/api/admission/todaywaitings`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAllWaitingListQueryKey = (params: GetAllWaitingListParams,) => {
    return [`/api/admission/todaywaitings`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllWaitingListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllWaitingList>>>, TError = ErrorType<unknown>>(params: GetAllWaitingListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllWaitingListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllWaitingList>>> = ({ signal }) => getAllWaitingList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllWaitingListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllWaitingList>>>
export type GetAllWaitingListInfiniteQueryError = ErrorType<unknown>


export function useGetAllWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllWaitingList>>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllWaitingList>>,
          TError,
          Awaited<ReturnType<typeof getAllWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllWaitingList>>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllWaitingList>>,
          TError,
          Awaited<ReturnType<typeof getAllWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllWaitingList>>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïò§Îäò ÌôòÏûê Ï†ëÏàò Î™ÖÎã®
 */

export function useGetAllWaitingListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllWaitingList>>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllWaitingListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllWaitingListQueryOptions = <TData = Awaited<ReturnType<typeof getAllWaitingList>>, TError = ErrorType<unknown>>(params: GetAllWaitingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllWaitingListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllWaitingList>>> = ({ signal }) => getAllWaitingList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllWaitingListQueryResult = NonNullable<Awaited<ReturnType<typeof getAllWaitingList>>>
export type GetAllWaitingListQueryError = ErrorType<unknown>


export function useGetAllWaitingList<TData = Awaited<ReturnType<typeof getAllWaitingList>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllWaitingList>>,
          TError,
          Awaited<ReturnType<typeof getAllWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllWaitingList<TData = Awaited<ReturnType<typeof getAllWaitingList>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllWaitingList>>,
          TError,
          Awaited<ReturnType<typeof getAllWaitingList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllWaitingList<TData = Awaited<ReturnType<typeof getAllWaitingList>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ïò§Îäò ÌôòÏûê Ï†ëÏàò Î™ÖÎã®
 */

export function useGetAllWaitingList<TData = Awaited<ReturnType<typeof getAllWaitingList>>, TError = ErrorType<unknown>>(
 params: GetAllWaitingListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWaitingList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllWaitingListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÌôòÏûê Ï†ïÎ≥¥ Ï∞æÍ∏∞
 * @summary Ï†ÑÏ≤¥ ÌôòÏûê Î™ÖÎã®
 */
export const getAllPatientsByName = (
    params: GetAllPatientsByNameParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAllPatientsByName200>(
      {url: `/api/admission/patients`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAllPatientsByNameQueryKey = (params: GetAllPatientsByNameParams,) => {
    return [`/api/admission/patients`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllPatientsByNameInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllPatientsByName>>>, TError = ErrorType<unknown>>(params: GetAllPatientsByNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllPatientsByNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPatientsByName>>> = ({ signal }) => getAllPatientsByName(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllPatientsByNameInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPatientsByName>>>
export type GetAllPatientsByNameInfiniteQueryError = ErrorType<unknown>


export function useGetAllPatientsByNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllPatientsByName>>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPatientsByName>>,
          TError,
          Awaited<ReturnType<typeof getAllPatientsByName>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPatientsByNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllPatientsByName>>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPatientsByName>>,
          TError,
          Awaited<ReturnType<typeof getAllPatientsByName>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPatientsByNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllPatientsByName>>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï†ÑÏ≤¥ ÌôòÏûê Î™ÖÎã®
 */

export function useGetAllPatientsByNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllPatientsByName>>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllPatientsByNameInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllPatientsByNameQueryOptions = <TData = Awaited<ReturnType<typeof getAllPatientsByName>>, TError = ErrorType<unknown>>(params: GetAllPatientsByNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllPatientsByNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPatientsByName>>> = ({ signal }) => getAllPatientsByName(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllPatientsByNameQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPatientsByName>>>
export type GetAllPatientsByNameQueryError = ErrorType<unknown>


export function useGetAllPatientsByName<TData = Awaited<ReturnType<typeof getAllPatientsByName>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPatientsByName>>,
          TError,
          Awaited<ReturnType<typeof getAllPatientsByName>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPatientsByName<TData = Awaited<ReturnType<typeof getAllPatientsByName>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPatientsByName>>,
          TError,
          Awaited<ReturnType<typeof getAllPatientsByName>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPatientsByName<TData = Awaited<ReturnType<typeof getAllPatientsByName>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï†ÑÏ≤¥ ÌôòÏûê Î™ÖÎã®
 */

export function useGetAllPatientsByName<TData = Awaited<ReturnType<typeof getAllPatientsByName>>, TError = ErrorType<unknown>>(
 params: GetAllPatientsByNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPatientsByName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllPatientsByNameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ìï¥ÎãπÌôòÏûêÏùò Ï†ëÏàò ÎÇ¥Ïó≠
 * @summary ÏàòÎÇ© Î™ÖÎã® Ï°∞Ìöå
 */
export const getAdmissionListBySearchValue = (
    params: GetAdmissionListBySearchValueParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdmissionListBySearchValue200>(
      {url: `/api/admission/admission-list`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAdmissionListBySearchValueQueryKey = (params: GetAdmissionListBySearchValueParams,) => {
    return [`/api/admission/admission-list`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAdmissionListBySearchValueInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>, TError = ErrorType<unknown>>(params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionListBySearchValueQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>> = ({ signal }) => getAdmissionListBySearchValue(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionListBySearchValueInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>
export type GetAdmissionListBySearchValueInfiniteQueryError = ErrorType<unknown>


export function useGetAdmissionListBySearchValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionListBySearchValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionListBySearchValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏàòÎÇ© Î™ÖÎã® Ï°∞Ìöå
 */

export function useGetAdmissionListBySearchValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionListBySearchValueInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdmissionListBySearchValueQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError = ErrorType<unknown>>(params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionListBySearchValueQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>> = ({ signal }) => getAdmissionListBySearchValue(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionListBySearchValueQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>>
export type GetAdmissionListBySearchValueQueryError = ErrorType<unknown>


export function useGetAdmissionListBySearchValue<TData = Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionListBySearchValue<TData = Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionListBySearchValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionListBySearchValue<TData = Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏàòÎÇ© Î™ÖÎã® Ï°∞Ìöå
 */

export function useGetAdmissionListBySearchValue<TData = Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError = ErrorType<unknown>>(
 params: GetAdmissionListBySearchValueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionListBySearchValue>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionListBySearchValueQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



